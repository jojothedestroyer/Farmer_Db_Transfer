{% load static %} {% load pwa %} {% progressive_web_app_meta %}

<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="manifest" href="('/static/manifest.json)" />
    <!-- <script src="/static/js/true_sync.js"></script> -->
    <!-- <script src="/static/js/indexeddb.js"></script> 
 -->
    {% comment %}
    <script>
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker
          .register("/static/js/serviceworker.js")
          .then(function (registration) {
            console.log(
              "Service Worker registered with scope:",
              registration.scope
            );
          })
          .catch(function (error) {
            console.error("Service Worker registration failed:", error);
          });
      }
    </script>
    {% endcomment %}
    <script>
        {% comment %} // Check if the service worker is available in the browser
        if ('serviceWorker' in navigator) {
            // Register the service worker
            navigator.serviceWorker.register('/static/js/serviceworker.js')
                .then(function (registration) {
                    console.log('Service Worker registered with scope:', registration.scope);
                })
                .catch(function (error) {
                    console.error('Service Worker registration failed:', error);
                });

            // Add a click event listener to the refresh cache button
            document.getElementById('refresh-cache-button').addEventListener('click', function () {
                // Send a message to the service worker to trigger cache refresh6
                navigator.serviceWorker.controller.postMessage({ action: 'refreshCache' });
            });
        }



        navigator.serviceWorker.addEventListener('message', (event) => {
          if (event.data === 'Caching complete!') {
              // Display the message to the user
              console.log(event.data);
              // You can replace the console.log with code to update your UI
          }
      }); {% endcomment %}



      // Check if the service worker is available in the browser
      if ('serviceWorker' in navigator) {
        // Register the service worker
        navigator.serviceWorker.register('/static/js/serviceworker.js')
            .then(function (registration) {
                console.log('Service Worker registered with scope:', registration.scope);
            })
            .catch(function (error) {
                console.error('Service Worker registration failed:', error);
            });

        // Add a click event listener to the refresh cache button
        document.getElementById('refresh-cache-button').addEventListener('click', function () {
            // Send a message to the service worker to trigger cache refresh
            navigator.serviceWorker.controller.postMessage({ action: 'refreshCache' });
        });
      }

      navigator.serviceWorker.addEventListener('message', (event) => {
        if (event.data === 'Caching complete!') {
            // Display the message to the user in a modal
            let modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.zIndex = '1';
            modal.style.left = '0';
            modal.style.top = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.overflow = 'auto';
            modal.style.backgroundColor = 'rgba(0,0,0,0.4)';

            let modalContent = document.createElement('div');
            modalContent.style.backgroundColor = '#fefefe';
            modalContent.style.margin = '15% auto';
            modalContent.style.padding = '20px';
            modalContent.style.border = '1px solid #888';
            modalContent.style.width = '80%';

            let closeBtn = document.createElement('span');
            closeBtn.style.color = '#aaaaaa';
            closeBtn.style.float = 'right';
            closeBtn.style.fontSize = '28px';
            closeBtn.style.fontWeight = 'bold';
            closeBtn.innerHTML = 'Ã—';
            closeBtn.onclick = function() {
                modal.style.display = 'none';
            }

            let text = document.createElement('p');
            text.innerText = event.data;

            modalContent.appendChild(closeBtn);
            modalContent.appendChild(text);
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        }
      });
    </script>
    <!-- 
    <script>
      //     const modelNames =  [
      //     'Worker', 'Farmer', 'DriedA', 'DriedB', 'FloatA', 'FloatB', 'Quaility', 'visit',
      //     'In-House-Drying', 'Dispatch-Of-Dried-Nutmeg', 'Dispatch-Of-Green', 'Cracking-Summary',
      //     'Floation-Summary', 'Package-Ciontrol', 'Editors', 'Labour-support', 'Training-support',
      //     'land-info', 'Land-Tenur', 'Nutmeg-Trees', 'Nutmeg-Variety', 'Other-Crops', 'Coconut-Trees',
      //     'Citrus-Mango-Trees', 'Other-Spices-Trees', 'Other-Seasoning-Trees', 'Other-Crops-Cultivated',
      //     'Condition', 'Nutmeg-Land', 'Nutmeg-Frequency', 'Potential-Risks', 'Road-Access',
      //     'Food-Safety-and-Quality', 'Farm-Water-Source', 'Farm-House', 'inspector-symmary', 'Policy',
      //     'Sanitation-A','Sanitation-B','Sanitation-C','Cracking_Schedule','Assorting_Log',
      //     'Extractor_Log','Fumigation_Log','Shelves','W_Shelves','M_Shelves','W_Shelves_Dried',
      //     'M_Shelves_Dried','Vehicle_Inspection','Final_Weight_Inspection','Final_Weight_Inspection_fields',
      //     'Dispatch_Of_Dried_Nutmeg_Rec','Dispatch_Of_Green_Nutmeg_Rec','Cracking_Extraction_Summary'
      // ];

      const modelNames = [
        "Worker",
        "Farmer",
        "DriedA",
        "DriedB",
        "FloatA",
        "FloatB",
        "Quaility",
        "visit",
        "In-House-Drying",
        "Dispatch-Of-Dried-Nutmeg",
        "Dispatch-Of-Green",
        "Cracking-Summary",
        "Floation-Summary",
        "Package-Ciontrol",
        "Editors",
        "Labour-support",
        "Training-support",
        "land-info",
        "Land-Tenur",
        "Nutmeg-Trees",
        "Nutmeg-Variety",
        "Other-Crops",
        "Coconut-Trees",
        "Citrus-Mango-Trees",
        "Other-Spices-Trees",
        "Other-Seasoning-Trees",
        "Other-Crops-Cultivated",
        "Condition",
        "Nutmeg-Land",
        "Nutmeg-Frequency",
        "Potential-Risks",
        "Road-Access",
        "Food-Safety-and-Quality",
        "Farm-Water-Source",
        "Farm-House",
        "inspector-symmary",
        "Policy",
        "Sanitation-A",
        "Sanitation-B",
        "Sanitation-C",
        "Cracking_Schedule",
        "Assorting_Log",
        "Extractor_Log",
        "Fumigation_Log",
        "Shelves",
        "W_Shelves",
        "M_Shelves",
        "W_Shelves_Dried",
        "M_Shelves_Dried",
        "Vehicle_Inspection",
        "Final_Weight_Inspection",
        "Final_Weight_Inspection_fields",
        "Dispatch_Of_Dried_Nutmeg_Rec",
        "Dispatch_Of_Green_Nutmeg_Rec",
        "Mace_Dispatched",
        "Mace_Purchase",
        "Mace_Dispatched_Rec",
      ];

      function deleteDatabase(dbName) {
        return new Promise((resolve, reject) => {
          const request = indexedDB.deleteDatabase(dbName);
          request.onsuccess = function () {
            resolve();
          };
          request.onerror = function (event) {
            reject(event.target.error);
          };
        });
      }

      function openIndexedDBConnection(dbName) {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(dbName, 2);
          request.onupgradeneeded = function (event) {
            const db = event.target.result;
            modelNames.forEach((modelName) => {
              if (!db.objectStoreNames.contains(modelName)) {
                db.createObjectStore(modelName, { keyPath: "id" });
              }
            });
          };
          request.onsuccess = function (event) {
            resolve(event.target.result);
          };
          request.onerror = function (event) {
            reject(event.target.error);
          };
        });
      }

      function fetchDataAndStore(db, modelName) {
        return new Promise((resolve, reject) => {
          fetch(`/api/${modelName}/`)
            .then((response) => response.json())
            .then((data) => {
              const transaction = db.transaction(modelName, "readwrite");
              const objectStore = transaction.objectStore(modelName);
              data.forEach((item) => {
                objectStore.put(item);
              });

              transaction.oncomplete = function () {
                resolve();
              };
            })
            .catch((error) => {
              console.error("Error fetching data for model:", modelName, error);
              reject(error);
            });
        });
      }

      // Create visual feedback elements
      const loadingMessage = document.createElement("div");
      loadingMessage.id = "loadingMessage";
      loadingMessage.innerHTML = "Loading database, please wait...";
      document.body.appendChild(loadingMessage);

      const progressBar = document.createElement("progress");
      progressBar.id = "progressBar";
      progressBar.max = modelNames.length;
      progressBar.value = 0;
      document.body.appendChild(progressBar);

      // Create "GCNA" database
      const gcnaDBName = "GCNA";

      deleteDatabase(gcnaDBName)
        .then(() => openIndexedDBConnection(gcnaDBName))
        .then((db) => {
          let completed = 0;
          const updateProgressBar = () => {
            completed++;
            progressBar.value = completed;
            if (completed === modelNames.length) {
              loadingMessage.innerHTML =
                'Database "GCNA" created successfully with data.';
            }
          };
          return Promise.all(
            modelNames.map((modelName) =>
              fetchDataAndStore(db, modelName).then(updateProgressBar)
            )
          );
        })
        .catch((error) => {
          console.error(`Error creating database "${gcnaDBName}":`, error);
          loadingMessage.innerHTML = `Error creating database "${gcnaDBName}": ${error.message}`;
        });

      // Create "DELETED" database
      const deletedDBName = "DELETED";

      deleteDatabase(deletedDBName)
        .then(() => openIndexedDBConnection(deletedDBName))
        .then((db) => {
          db.close();
          console.log(
            `Database "${deletedDBName}" created successfully with empty object stores.`
          );
        })
        .catch((error) =>
          console.error(`Error creating database "${deletedDBName}":`, error)
        );
    </script> -->
    <!-- <script>
      const modelNames = [
        "Worker",
        "Farmer",
        "DriedA",
        "DriedB",
        "FloatA",
        "FloatB",
        "Quaility",
        "visit",
        "In-House-Drying",
        "Dispatch-Of-Dried-Nutmeg",
        "Dispatch-Of-Green",
        "Cracking-Summary",
        "Floation-Summary",
        "Package-Ciontrol",
        "Editors",
        "Labour-support",
        "Training-support",
        "land-info",
        "Land-Tenur",
        "Nutmeg-Trees",
        "Nutmeg-Variety",
        "Other-Crops",
        "Coconut-Trees",
        "Citrus-Mango-Trees",
        "Other-Spices-Trees",
        "Other-Seasoning-Trees",
        "Other-Crops-Cultivated",
        "Condition",
        "Nutmeg-Land",
        "Nutmeg-Frequency",
        "Potential-Risks",
        "Road-Access",
        "Food-Safety-and-Quality",
        "Farm-Water-Source",
        "Farm-House",
        "inspector-symmary",
        "Policy",
        "Sanitation-A",
        "Sanitation-B",
        "Sanitation-C",
        "Cracking_Schedule",
        "Assorting_Log",
        "Extractor_Log",
        "Fumigation_Log",
        "Shelves",
        "W_Shelves",
        "M_Shelves",
        "W_Shelves_Dried",
        "M_Shelves_Dried",
        "Vehicle_Inspection",
        "Final_Weight_Inspection",
        "Final_Weight_Inspection_fields",
        "Dispatch_Of_Dried_Nutmeg_Rec",
        "Dispatch_Of_Green_Nutmeg_Rec",
        "Cracking_Extraction_Summary",
        "Mace_Dispatched",
        "Mace_Purchase",
        "Mace_Dispatched_Rec",
        "Day_Of_Loading",
        "TruckEntry",
        "Container_Inspection_Log",
      ];

      function deleteDatabase(dbName) {
        return new Promise((resolve, reject) => {
          const request = indexedDB.deleteDatabase(dbName);
          request.onsuccess = function () {
            resolve();
          };
          request.onerror = function (event) {
            reject(event.target.error);
          };
        });
      }

      function openIndexedDBConnection(dbName) {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(dbName, 2);
          request.onupgradeneeded = function (event) {
            const db = event.target.result;
            modelNames.forEach((modelName) => {
              if (!db.objectStoreNames.contains(modelName)) {
                db.createObjectStore(modelName, { keyPath: "id" });
              }
            });
          };
          request.onsuccess = function (event) {
            resolve(event.target.result);
          };
          request.onerror = function (event) {
            reject(event.target.error);
          };
        });
      }

      function fetchDataAndStore(db, modelName) {
        return new Promise((resolve, reject) => {
          fetch(`/api/${modelName}/`)
            .then((response) => response.json())
            .then((data) => {
              const transaction = db.transaction(modelName, "readwrite");
              const objectStore = transaction.objectStore(modelName);
              data.forEach((item) => {
                objectStore.put(item);
              });
              transaction.oncomplete = function () {
                resolve();
              };
            })
            .catch((error) => {
              console.error("Error fetching data for model:", modelName, error);
              reject(error);
            });
        });
      }

      // Sync data every 30 seconds if the GCNA database exists
      setInterval(syncIndexedDBData, 30000);

      function syncIndexedDBData() {
        const request = indexedDB.open("GCNA", 2);
        request.onsuccess = function (event) {
          const db = event.target.result;
          modelNames.forEach((modelName) => {
            const transaction = db.transaction(modelName, "readonly");
            const objectStore = transaction.objectStore(modelName);
            const getRequest = objectStore.getAll();

            getRequest.onsuccess = function (event) {
              const data = event.target.result;
              data.forEach((item) => {
                sendDataToDjango(item, modelName);
              });
            };
          });
        };
        request.onerror = function (event) {
          console.error("Error opening IndexedDB", event);
        };
      }

      function sendDataToDjango(item, modelName) {
        const xhr = new XMLHttpRequest();
        xhr.open("POST", "/check-and-add/", true);
        xhr.setRequestHeader("Content-Type", "application/json");
        xhr.onreadystatechange = function () {
          if (xhr.readyState === XMLHttpRequest.DONE) {
            if (xhr.status === 200) {
              console.log(
                "Entry added successfully for model:",
                modelName,
                item.id
              );
            } else {
              console.error(
                "Error adding entry for model:",
                modelName,
                xhr.statusText
              );
            }
          }
        };
        xhr.send(JSON.stringify({ model: modelName, data: item }));
      }

      // Initialize databases
      const gcnaDBName = "GCNA";
      deleteDatabase(gcnaDBName)
        .then(() => openIndexedDBConnection(gcnaDBName))
        .then((db) => {
          let completed = 0;
          const updateProgressBar = () => {
            completed++;
            progressBar.value = completed;
            if (completed === modelNames.length) {
              loadingMessage.innerHTML =
                'Database "GCNA" created successfully with data.';
            }
          };
          return Promise.all(
            modelNames.map((modelName) =>
              fetchDataAndStore(db, modelName).then(updateProgressBar)
            )
          );
        })
        .catch((error) => {
          console.error(`Error creating database "${gcnaDBName}":`, error);
          loadingMessage.innerHTML = `Error creating database "${gcnaDBName}": ${error.message}`;
        });

      // Create empty "DELETED" database
      const deletedDBName = "DELETED";
      deleteDatabase(deletedDBName)
        .then(() => openIndexedDBConnection(deletedDBName))
        .then((db) => {
          db.close();
          console.log(
            `Database "${deletedDBName}" created successfully with empty object stores.`
          );
        })
        .catch((error) =>
          console.error(`Error creating database "${deletedDBName}":`, error)
        );
    </script> -->
    <!-- <script type="module">
      // Import Firebase modules
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-app.js";
      import { getDatabase, ref, set, get, query, orderByChild, equalTo } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-database.js";
      import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-auth.js";
    
      // Firebase configuration
      const firebaseConfig = {
        apiKey: "AIzaSyBZTB_mN_gIb6mqeM8nid4x83oKRehmFKo",
        authDomain: "farmer-project-sync.firebaseapp.com",
        databaseURL: "https://farmer-project-sync-default-rtdb.firebaseio.com",
        projectId: "farmer-project-sync",
        storageBucket: "farmer-project-sync.firebasestorage.app",
        messagingSenderId: "1366353203",
        appId: "1:1366353203:web:fa29fd29cc326a0d63ca46"
      };
    
      // Initialize Firebase
      const app = initializeApp(firebaseConfig);
      const db = getDatabase(app);
      const auth = getAuth(app);
    
      document.addEventListener("DOMContentLoaded", async function () {
        console.log("Initializing IndexedDB...");
        await initializeIndexedDB(); // Initialize IndexedDB first
        console.log("Finished initializing IndexedDB.");
        checkUserAndSyncData();
      });
    
      // Initialize IndexedDB and create object stores if they don't exist
      function initializeIndexedDB() {
        return new Promise((resolve, reject) => {
          const dbVersion = 2; // Increment this number if you change the schema
          var request = indexedDB.open("GCNA", dbVersion);
    
          request.onupgradeneeded = function (event) {
            var db = event.target.result;
            console.log("Database upgrade needed. Creating object stores...");
    
            const modelNames = [
              "Worker", "Farmer", "DriedA", "DriedB", "FloatA", "FloatB", "Quaility", "visit",
              "In-House-Drying", "Dispatch-Of-Dried-Nutmeg", "Dispatch-Of-Green", "Cracking-Summary",
              "Floation-Summary", "Package-Ciontrol", "Editors", "Labour-support", "Training-support",
              "land-info", "Land-Tenur", "Nutmeg-Trees", "Nutmeg-Variety", "Other-Crops", "Coconut-Trees",
              "Citrus-Mango-Trees", "Other-Spices-Trees", "Other-Seasoning-Trees", "Other-Crops-Cultivated",
              "Condition", "Nutmeg-Land", "Nutmeg-Frequency", "Potential-Risks", "Road-Access",
              "Food-Safety-and-Quality", "Farm-Water-Source", "Farm-House", "inspector-symmary", "Policy",
              "Sanitation-A", "Sanitation-B", "Sanitation-C", "Cracking_Schedule", "Assorting_Log",
              "Extractor_Log", "Fumigation_Log", "Shelves", "W_Shelves", "M_Shelves", "W_Shelves_Dried",
              "M_Shelves_Dried", "Vehicle_Inspection", "Final_Weight_Inspection", "Final_Weight_Inspection_fields",
              "Dispatch_Of_Dried_Nutmeg_Rec", "Dispatch_Of_Green_Nutmeg_Rec", "Mace_Dispatched", "Mace_Purchase",
              "Mace_Dispatched_Rec", "Cracking_Extraction_Summary", "Day_Of_Loading", "TruckEntry",
              "Container_Inspection_Log"
            ];
    
            modelNames.forEach((modelName) => {
              if (!db.objectStoreNames.contains(modelName)) {
                console.log(`Creating object store: ${modelName}`);
                db.createObjectStore(modelName, { keyPath: "id" }); // Store data by 'id'
              } else {
                console.log(`Object store already exists: ${modelName}`);
              }
            });
          };
    
          request.onsuccess = function (event) {
            console.log("IndexedDB initialized successfully.");
            resolve(event.target.result);
          };
    
          request.onerror = function (event) {
            console.error("Error opening IndexedDB:", event);
            reject("Error opening IndexedDB:", event);
          };
        });
      }
    
      async function checkUserAndSyncData() {
        console.log("Checking for current user...");
        const user = await getCurrentUser();
        if (!user) {
          console.log("No user found. Prompting for user creation...");
          showUserModal();
        } else {
          console.log("User found:", user.customUserId);
          syncDataWithFirebase(user.customUserId); // Use customUserId for syncing
        }
      }
    
      async function getCurrentUser() {
        // Check if customUserId is already stored in localStorage
        const customUserId = localStorage.getItem("customUserId");
        if (customUserId) {
          console.log("User ID found in localStorage:", customUserId);
          return { customUserId }; // Return customUserId if it exists
        }
    
        // If no customUserId is found, prompt the user to log in
        return null;
      }
    
      function showUserModal() {
        const userName = prompt("Please enter your name:");
        if (userName) {
          console.log("User name provided:", userName);
          createUser(userName);
        } else {
          console.log("No user name provided.");
        }
      }
    
      async function createUser(userName) {
        // Check if the user already exists in Firebase
        console.log("Searching for user in Firebase...");
        const existingUser = await findUserByName(userName);
        if (existingUser) {
          console.log("User already exists in Firebase:", existingUser);
          const customUserId = existingUser.customUserId;
          localStorage.setItem("customUserId", customUserId); // Save to localStorage
          console.log("User logged in successfully!");
          syncDataWithFirebase(customUserId);
        } else {
          console.log("User does not exist. Creating new user...");
          const customUserId = generateCustomUserId(userName);
          localStorage.setItem("customUserId", customUserId); // Save to localStorage
    
          // Save the username and customUserId in Firebase
          await set(ref(db, `Users/${customUserId}/name`), userName);
          console.log("User created successfully in Firebase!");
          syncDataWithFirebase(customUserId);
        }
      }
    
      async function findUserByName(userName) {
        // Query Firebase to find a user by name
        const usersRef = ref(db, "Users");
        const userQuery = query(usersRef, orderByChild("name"), equalTo(userName));
        const snapshot = await get(userQuery);
    
        if (snapshot.exists()) {
          // Return the first matching user's customUserId
          const userData = snapshot.val();
          const customUserId = Object.keys(userData)[0];
          console.log("User found in Firebase with customUserId:", customUserId);
          return { customUserId };
        } else {
          console.log("No user found in Firebase.");
          return null; // No user found
        }
      }
    
      function generateCustomUserId(userName) {
        // Generate a unique ID based on the username and a random string
        const randomString = Math.random().toString(36).substring(2, 10);
        return `${userName}-${randomString}`;
      }
    
      async function syncDataWithFirebase(customUserId) {
        console.log("Syncing data with Firebase for user:", customUserId);
        const indexedDBData = await getIndexedDBData();
    
        if (indexedDBData.length === 0) {
          console.log("IndexedDB is empty. Loading data from Firebase...");
          await loadDataFromFirebase(customUserId);
        } else {
          console.log("IndexedDB contains data. Uploading to Firebase...");
          await uploadDataToFirebase(customUserId, indexedDBData);
          console.log("Syncing IndexedDB with Firebase...");
          await syncIndexedDBWithFirebase(customUserId);
        }
      }
    
      async function getIndexedDBData() {
    const db = await initializeIndexedDB();
    return new Promise((resolve, reject) => {
        const modelNames = [
            "Worker", "Farmer", "DriedA", "DriedB", "FloatA", "FloatB", "Quaility", "visit", 
            "In-House-Drying", "Dispatch-Of-Dried-Nutmeg", "Dispatch-Of-Green", "Cracking-Summary", 
            "Floation-Summary", "Package-Ciontrol", "Editors", "Labour-support", "Training-support", 
            "land-info", "Land-Tenur", "Nutmeg-Trees", "Nutmeg-Variety", "Other-Crops", "Coconut-Trees", 
            "Citrus-Mango-Trees", "Other-Spices-Trees", "Other-Seasoning-Trees", "Other-Crops-Cultivated", 
            "Condition", "Nutmeg-Land", "Nutmeg-Frequency", "Potential-Risks", "Road-Access", 
            "Food-Safety-and-Quality", "Farm-Water-Source", "Farm-House", "inspector-symmary", "Policy", 
            "Sanitation-A", "Sanitation-B", "Sanitation-C", "Cracking_Schedule", "Assorting_Log", 
            "Extractor_Log", "Fumigation_Log", "Shelves", "W_Shelves", "M_Shelves", "W_Shelves_Dried", 
            "M_Shelves_Dried", "Vehicle_Inspection", "Final_Weight_Inspection", "Final_Weight_Inspection_fields", 
            "Dispatch_Of_Dried_Nutmeg_Rec", "Dispatch_Of_Green_Nutmeg_Rec", "Mace_Dispatched", "Mace_Purchase", 
            "Mace_Dispatched_Rec", "Cracking_Extraction_Summary", "Day_Of_Loading", "TruckEntry", 
            "Container_Inspection_Log"
        ];

        const allData = [];
        let completedRequests = 0;

        modelNames.forEach((modelName) => {
            console.log(`Attempting to fetch data for model: ${modelName}`);
            if (!db.objectStoreNames.contains(modelName)) {
                console.warn(`Object store not found: ${modelName}`);
                return; // Skip this model if object store doesn't exist
            }

            const transaction = db.transaction(modelName, "readonly");
            const objectStore = transaction.objectStore(modelName);
            const getRequest = objectStore.getAll();

            getRequest.onsuccess = function (event) {
                const data = event.target.result;
                console.log(`Fetched ${data.length} items from IndexedDB for ${modelName}.`);

                if (data.length > 0) {
                    allData.push({ modelName, data });
                } else {
                    console.log(`No items found for ${modelName}.`);
                }

                completedRequests++;
                if (completedRequests === modelNames.length) {
                    resolve(allData);
                }
            };

            getRequest.onerror = function (event) {
                console.error(`Error fetching data from IndexedDB for ${modelName}:`, event);
                completedRequests++;
                if (completedRequests === modelNames.length) {
                    resolve(allData); // Resolve with partial data if there are any fetch errors
                }
            };
        });
    });
}

      async function loadDataFromFirebase(customUserId) {
        console.log("Loading data from Firebase...");
        const snapshot = await get(ref(db, `Users/${customUserId}/models`));
        if (snapshot.exists()) {
          const data = snapshot.val();
          Object.keys(data).forEach((modelName) => {
            console.log(`Saving data for model: ${modelName}`);
            data[modelName].forEach((item) => {
              saveDataToIndexedDB(modelName, item);
            });
          });
        }
      }
    
      async function saveDataToIndexedDB(modelName, item) {
        const db = await initializeIndexedDB();
        const transaction = db.transaction(modelName, "readwrite");
        const objectStore = transaction.objectStore(modelName);
    
        // Check if the item already exists in IndexedDB (based on the id)
        const getRequest = objectStore.get(item.id);
        getRequest.onsuccess = function () {
          if (!getRequest.result) {
            objectStore.add(item); // Add if it doesn't already exist
            console.log(`Added item with id ${item.id} to IndexedDB for model ${modelName}`);
          }
        };
      }
    
      async function uploadDataToFirebase(customUserId, data) {
        console.log("Uploading data to Firebase...");
        for (const { modelName, data: items } of data) {
          const modelRef = ref(db, `Users/${customUserId}/models/${modelName}`);
    
          for (const item of items) {
            const itemId = item.id; // Get the id of the current item
    
            // Create a reference to the individual entry path
            const itemRef = ref(db, `Users/${customUserId}/models/${modelName}/${itemId}`);
    
            // Use the id to set the specific data entry under the model name
            console.log(`Uploading item with id ${itemId} for model ${modelName} to Firebase.`);
            await set(itemRef, item);
          }
        }
      }
    
      async function syncIndexedDBWithFirebase(customUserId) {
        console.log("Syncing IndexedDB with Firebase for user:", customUserId);
        const indexedDBData = await getIndexedDBData();
        
        for (const { modelName, data: items } of indexedDBData) {
          for (const item of items) {
            const itemId = item.id;
            const itemRef = ref(db, `Users/${customUserId}/models/${modelName}/${itemId}`);
            const snapshot = await get(itemRef);
    
            if (snapshot.exists()) {
              const firebaseItem = snapshot.val();
              if (JSON.stringify(firebaseItem) !== JSON.stringify(item)) {
                // Update Firebase if IndexedDB and Firebase data don't match
                console.log(`Updating Firebase for item with id ${itemId} in model ${modelName}`);
                await set(itemRef, item);
              }
            } else {
              // If the item does not exist in Firebase, add it
              console.log(`Adding new item with id ${itemId} to Firebase for model ${modelName}`);
              await set(itemRef, item);
            }
          }
        }
      }
    </script>
     -->
     <div id="loadingSpinner">Syncing data... Please wait...</div>
     <script type="module">
      // Import Firebase modules
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-app.js";
      import { getDatabase, ref, set, get, query, orderByChild, equalTo, update, push } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-database.js";
      import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-auth.js";
    
      // Firebase configuration
      const firebaseConfig = {
        apiKey: "AIzaSyBZTB_mN_gIb6mqeM8nid4x83oKRehmFKo",
        authDomain: "farmer-project-sync.firebaseapp.com",
        databaseURL: "https://farmer-project-sync-default-rtdb.firebaseio.com",
        projectId: "farmer-project-sync",
        storageBucket: "farmer-project-sync.firebasestorage.app",
        messagingSenderId: "1366353203",
        appId: "1:1366353203:web:fa29fd29cc326a0d63ca46"
      };
    
      // Initialize Firebase
      const app = initializeApp(firebaseConfig);
      const db = getDatabase(app);
      const auth = getAuth(app);
    
      document.addEventListener("DOMContentLoaded", async function () {
        console.log("Initializing IndexedDB...");
        await initializeIndexedDB(); // Initialize IndexedDB first
        console.log("Finished initializing IndexedDB.");
        checkUserAndSyncData();
      });
    
      // Initialize IndexedDB and create object stores if they don't exist
      function initializeIndexedDB() {
        return new Promise((resolve, reject) => {
          const dbVersion = 2; // Increment this number if you change the schema
          var request = indexedDB.open("GCNA", dbVersion);
    
          request.onupgradeneeded = function (event) {
            var db = event.target.result;
            console.log("Database upgrade needed. Creating object stores...");
    
            const modelNames = [
              "Worker", "Farmer", "DriedA", "DriedB", "FloatA", "FloatB", "Quaility", "visit",
              "In-House-Drying", "Dispatch-Of-Dried-Nutmeg", "Dispatch-Of-Green", "Cracking-Summary",
              "Floation-Summary", "Package-Ciontrol", "Editors", "Labour-support", "Training-support",
              "land-info", "Land-Tenur", "Nutmeg-Trees", "Nutmeg-Variety", "Other-Crops", "Coconut-Trees",
              "Citrus-Mango-Trees", "Other-Spices-Trees", "Other-Seasoning-Trees", "Other-Crops-Cultivated",
              "Condition", "Nutmeg-Land", "Nutmeg-Frequency", "Potential-Risks", "Road-Access",
              "Food-Safety-and-Quality", "Farm-Water-Source", "Farm-House", "inspector-symmary", "Policy",
              "Sanitation-A", "Sanitation-B", "Sanitation-C", "Cracking_Schedule", "Assorting_Log",
              "Extractor_Log", "Fumigation_Log", "Shelves", "W_Shelves", "M_Shelves", "W_Shelves_Dried",
              "M_Shelves_Dried", "Vehicle_Inspection", "Final_Weight_Inspection", "Final_Weight_Inspection_fields",
              "Dispatch_Of_Dried_Nutmeg_Rec", "Dispatch_Of_Green_Nutmeg_Rec", "Mace_Dispatched", "Mace_Purchase",
              "Mace_Dispatched_Rec", "Cracking_Extraction_Summary", "Day_Of_Loading", "TruckEntry",
              "Container_Inspection_Log"
            ];
    
            modelNames.forEach((modelName) => {
              if (!db.objectStoreNames.contains(modelName)) {
                console.log(`Creating object store: ${modelName}`);
                db.createObjectStore(modelName, { keyPath: "id" }); // Store data by 'id'
              } else {
                console.log(`Object store already exists: ${modelName}`);
              }
            });
          };
    
          request.onsuccess = function (event) {
            console.log("IndexedDB initialized successfully.");
            resolve(event.target.result);
          };
    
          request.onerror = function (event) {
            console.error("Error opening IndexedDB:", event);
            reject("Error opening IndexedDB:", event);
          };
        });
      }
    
      async function checkUserAndSyncData() {
        console.log("Checking for current user...");
        const user = await getCurrentUser();
        if (!user) {
          console.log("No user found. Prompting for user creation...");
          showUserModal();
        } else {
          console.log("User found:", user.customUserId);
          if (navigator.onLine) {
            syncDataWithFirebase(user.customUserId); // Use customUserId for syncing only when online
          } else {
            console.log("User is offline, will sync when online.");
          }
        }
      }
    
      async function getCurrentUser() {
        // Check if customUserId is already stored in localStorage
        const customUserId = localStorage.getItem("customUserId");
        if (customUserId) {
          console.log("User ID found in localStorage:", customUserId);
          return { customUserId }; // Return customUserId if it exists
        }
    
        // If no customUserId is found, prompt the user to log in
        return null;
      }
    
      function showUserModal() {
        const userName = prompt("Please enter your name:");
        if (userName) {
          console.log("User name provided:", userName);
          createUser(userName);
        } else {
          console.log("No user name provided.");
        }
      }
    
      async function createUser(userName) {
        // Check if the user already exists in Firebase
        console.log("Searching for user in Firebase...");
        const existingUser = await findUserByName(userName);
        if (existingUser) {
          console.log("User already exists in Firebase:", existingUser);
          const customUserId = existingUser.customUserId;
          localStorage.setItem("customUserId", customUserId); // Save to localStorage
          console.log("User logged in successfully!");
          if (navigator.onLine) {
            syncDataWithFirebase(customUserId); // Sync data if online
          }
        } else {
          console.log("User does not exist. Creating new user...");
          const customUserId = generateCustomUserId(userName);
          localStorage.setItem("customUserId", customUserId); // Save to localStorage
    
          // Save the username and customUserId in Firebase
          await set(ref(db, `Users/${customUserId}/name`), userName);
          console.log("User created successfully in Firebase!");
          if (navigator.onLine) {
            syncDataWithFirebase(customUserId); // Sync data if online
          }
        }
      }
    
      async function findUserByName(userName) {
        // Query Firebase to find a user by name
        const usersRef = ref(db, "Users");
        const userQuery = query(usersRef, orderByChild("name"), equalTo(userName));
        const snapshot = await get(userQuery);
    
        if (snapshot.exists()) {
          // Return the first matching user's customUserId
          const userData = snapshot.val();
          const customUserId = Object.keys(userData)[0];
          console.log("User found in Firebase with customUserId:", customUserId);
          return { customUserId };
        } else {
          console.log("No user found in Firebase.");
          return null; // No user found
        }
      }
    
      function generateCustomUserId(userName) {
        // Generate a unique ID based on the username and a random string
        const randomString = Math.random().toString(36).substring(2, 10);
        return `${userName}-${randomString}`;
      }
    
      async function syncDataWithFirebase(customUserId) {
        disableUserInteraction(); // Disable user interaction while syncing
        showLoadingSpinner(true); // Show the loading spinner
        console.log("Syncing data with Firebase for user:", customUserId);
        const indexedDBData = await getIndexedDBData();
        await loadDataFromFirebase(customUserId);
    
        if (indexedDBData.length === 0) {
          console.log("IndexedDB is empty. Loading data from Firebase...");
          await loadDataFromFirebase(customUserId);
        } else {
          console.log("IndexedDB contains data. Uploading to Firebase...");
          await uploadDataToFirebase(customUserId, indexedDBData);
    
          console.log("Syncing IndexedDB with Firebase...");
          await syncIndexedDBWithFirebase(customUserId);
        }
        hideLoadingSpinner(); // Hide the loading spinner
        enableUserInteraction(); // Re-enable user interaction after syncing
      }
    
      async function getIndexedDBData() {
        const db = await initializeIndexedDB();
        return new Promise((resolve, reject) => {
          const modelNames = [
            "Worker", "Farmer", "DriedA", "DriedB", "FloatA", "FloatB", "Quaility", "visit",
            "In-House-Drying", "Dispatch-Of-Dried-Nutmeg", "Dispatch-Of-Green", "Cracking-Summary",
            "Floation-Summary", "Package-Ciontrol", "Editors", "Labour-support", "Training-support",
            "land-info", "Land-Tenur", "Nutmeg-Trees", "Nutmeg-Variety", "Other-Crops", "Coconut-Trees",
            "Citrus-Mango-Trees", "Other-Spices-Trees", "Other-Seasoning-Trees", "Other-Crops-Cultivated",
            "Condition", "Nutmeg-Land", "Nutmeg-Frequency", "Potential-Risks", "Road-Access",
            "Food-Safety-and-Quality", "Farm-Water-Source", "Farm-House", "inspector-symmary", "Policy",
            "Sanitation-A", "Sanitation-B", "Sanitation-C", "Cracking_Schedule", "Assorting_Log",
            "Extractor_Log", "Fumigation_Log", "Shelves", "W_Shelves", "M_Shelves", "W_Shelves_Dried",
            "M_Shelves_Dried", "Vehicle_Inspection", "Final_Weight_Inspection", "Final_Weight_Inspection_fields",
            "Dispatch_Of_Dried_Nutmeg_Rec", "Dispatch_Of_Green_Nutmeg_Rec", "Mace_Dispatched", "Mace_Purchase",
            "Mace_Dispatched_Rec", "Cracking_Extraction_Summary", "Day_Of_Loading", "TruckEntry",
            "Container_Inspection_Log"
          ];
    
          const allData = [];
    
          modelNames.forEach((modelName) => {
            const transaction = db.transaction(modelName, "readonly");
            const store = transaction.objectStore(modelName);
            const request = store.getAll();
    
            request.onsuccess = function () {
              allData.push({ modelName, data: request.result });
              if (allData.length === modelNames.length) {
                resolve(allData);
              }
            };
    
            request.onerror = function () {
              reject("Error reading data from IndexedDB");
            };
          });
        });
      }
    
      async function uploadDataToFirebase(customUserId, data) {
        try {
          console.log("Uploading data to Firebase...");
          const userRef = ref(db, `Users/${customUserId}/models`);
    
          for (const model of data) {
            const modelName = model.modelName;
            const modelData = model.data;
    
            const modelRef = ref(db, `Users/${customUserId}/models/${modelName}`);
            // Use the existing ids in the data rather than creating new unique keys
            modelData.forEach(async (item) => {
              const itemRef = ref(db, `Users/${customUserId}/models/${modelName}/${item.id}`);
              await set(itemRef, item); // Use the built-in id as the key
            });
    
            console.log(`Uploaded ${modelData.length} items to Firebase for model ${modelName}`);
          }
    
          console.log("Data uploaded successfully to Firebase.");
        } catch (error) {
          console.error("Error uploading data to Firebase:", error);
        }
      }
    
      async function loadDataFromFirebase(customUserId) {
        console.log("Loading data from Firebase...");
        const userRef = ref(db, `Users/${customUserId}/models`);
        const snapshot = await get(userRef);
    
        if (snapshot.exists()) {
          const data = snapshot.val();
          for (const modelName in data) {
            const modelData = data[modelName];
            console.log(`Loading ${modelName} from Firebase`);
            await loadModelToIndexedDB(modelName, modelData);
          }
          console.log("Data successfully loaded from Firebase.");
        } else {
          console.log("No data found in Firebase.");
        }
      }
    
      async function loadModelToIndexedDB(modelName, modelData) {
  const db = await initializeIndexedDB();
  const transaction = db.transaction(modelName, "readwrite");
  const store = transaction.objectStore(modelName);

  // Log the modelData type and content for debugging purposes
  console.log(`modelData for ${modelName}:`, modelData);
  console.log(`Type of modelData for ${modelName}:`, typeof modelData);

  // Check if modelData is an array
  if (Array.isArray(modelData)) {
    modelData.forEach(item => {
      // Ensure that the item has the necessary 'id' field
      if (item && item.id) {
        store.put(item); // Add or update the record in IndexedDB
      } else {
        console.error(`Item is missing 'id' field for model ${modelName}:`, item);
      }
    });
  }
  // Check if modelData is an object (but not an array)
  else if (modelData && typeof modelData === 'object') {
    // If it's an object, convert it to an array of its values and iterate
    Object.values(modelData).forEach(item => {
      // Ensure that the item has the necessary 'id' field
      if (item && item.id) {
        store.put(item); // Add or update the record in IndexedDB
      } else {
        console.error(`Item is missing 'id' field for model ${modelName}:`, item);
      }
    });
  } else {
    // Handle other cases where modelData is neither an array nor an object
    console.error(`Unexpected modelData type for ${modelName}:`, modelData);
  }
}

    
      async function syncIndexedDBWithFirebase(customUserId) {
        console.log("Syncing IndexedDB with Firebase...");
    
        // First, get all the data from IndexedDB
        const indexedDBData = await getIndexedDBData();
        for (const model of indexedDBData) {
          const modelName = model.modelName;
          const modelData = model.data;
    
          // Upload the model data to Firebase
          await uploadDataToFirebase(customUserId, [{ modelName, data: modelData }]);
        }
        console.log("IndexedDB synced with Firebase.");
      }
    
      function disableUserInteraction() {
        // Disable interaction while syncing
        document.body.style.pointerEvents = "none";
        console.log("User interaction disabled.");
      }
    
      function enableUserInteraction() {
        // Enable interaction after syncing
        document.body.style.pointerEvents = "auto";
        console.log("User interaction enabled.");
      }
    
      function showLoadingSpinner(show) {
        const spinner = document.getElementById("loadingSpinner");
        if (show) {
          spinner.style.display = "block";
        } else {
          spinner.style.display = "none";
        }
      }
    
      function hideLoadingSpinner() {
        showLoadingSpinner(false);
      }
    
    </script>
    
     <!-- <script type="module">
      // Import Firebase modules
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-app.js";
      import { getDatabase, ref, set, get, query, orderByChild, equalTo, update, push } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-database.js";
      import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-auth.js";
    
      // Firebase configuration
      const firebaseConfig = {
        apiKey: "AIzaSyBZTB_mN_gIb6mqeM8nid4x83oKRehmFKo",
        authDomain: "farmer-project-sync.firebaseapp.com",
        databaseURL: "https://farmer-project-sync-default-rtdb.firebaseio.com",
        projectId: "farmer-project-sync",
        storageBucket: "farmer-project-sync.firebasestorage.app",
        messagingSenderId: "1366353203",
        appId: "1:1366353203:web:fa29fd29cc326a0d63ca46"
      };
    
      // Initialize Firebase
      const app = initializeApp(firebaseConfig);
      const db = getDatabase(app);
      const auth = getAuth(app);
    
      document.addEventListener("DOMContentLoaded", async function () {
        console.log("Initializing IndexedDB...");
        await initializeIndexedDB(); // Initialize IndexedDB first
        console.log("Finished initializing IndexedDB.");
        checkUserAndSyncData();
      });
    
      // Initialize IndexedDB and create object stores if they don't exist
      function initializeIndexedDB() {
        return new Promise((resolve, reject) => {
          const dbVersion = 2; // Increment this number if you change the schema
          var request = indexedDB.open("GCNA", dbVersion);
    
          request.onupgradeneeded = function (event) {
            var db = event.target.result;
            console.log("Database upgrade needed. Creating object stores...");
    
            const modelNames = [
              "Worker", "Farmer", "DriedA", "DriedB", "FloatA", "FloatB", "Quaility", "visit",
              "In-House-Drying", "Dispatch-Of-Dried-Nutmeg", "Dispatch-Of-Green", "Cracking-Summary",
              "Floation-Summary", "Package-Ciontrol", "Editors", "Labour-support", "Training-support",
              "land-info", "Land-Tenur", "Nutmeg-Trees", "Nutmeg-Variety", "Other-Crops", "Coconut-Trees",
              "Citrus-Mango-Trees", "Other-Spices-Trees", "Other-Seasoning-Trees", "Other-Crops-Cultivated",
              "Condition", "Nutmeg-Land", "Nutmeg-Frequency", "Potential-Risks", "Road-Access",
              "Food-Safety-and-Quality", "Farm-Water-Source", "Farm-House", "inspector-symmary", "Policy",
              "Sanitation-A", "Sanitation-B", "Sanitation-C", "Cracking_Schedule", "Assorting_Log",
              "Extractor_Log", "Fumigation_Log", "Shelves", "W_Shelves", "M_Shelves", "W_Shelves_Dried",
              "M_Shelves_Dried", "Vehicle_Inspection", "Final_Weight_Inspection", "Final_Weight_Inspection_fields",
              "Dispatch_Of_Dried_Nutmeg_Rec", "Dispatch_Of_Green_Nutmeg_Rec", "Mace_Dispatched", "Mace_Purchase",
              "Mace_Dispatched_Rec", "Cracking_Extraction_Summary", "Day_Of_Loading", "TruckEntry",
              "Container_Inspection_Log"
            ];
    
            modelNames.forEach((modelName) => {
              if (!db.objectStoreNames.contains(modelName)) {
                console.log(`Creating object store: ${modelName}`);
                db.createObjectStore(modelName, { keyPath: "id" }); // Store data by 'id'
              } else {
                console.log(`Object store already exists: ${modelName}`);
              }
            });
          };
    
          request.onsuccess = function (event) {
            console.log("IndexedDB initialized successfully.");
            resolve(event.target.result);
          };
    
          request.onerror = function (event) {
            console.error("Error opening IndexedDB:", event);
            reject("Error opening IndexedDB:", event);
          };
        });
      }
    
      async function checkUserAndSyncData() {
        console.log("Checking for current user...");
        const user = await getCurrentUser();
        if (!user) {
          console.log("No user found. Prompting for user creation...");
          showUserModal();
        } else {
          console.log("User found:", user.customUserId);
          if (navigator.onLine) {
            syncDataWithFirebase(user.customUserId); // Use customUserId for syncing only when online
          } else {
            console.log("User is offline, will sync when online.");
          }
        }
      }
    
      async function getCurrentUser() {
        // Check if customUserId is already stored in localStorage
        const customUserId = localStorage.getItem("customUserId");
        if (customUserId) {
          console.log("User ID found in localStorage:", customUserId);
          return { customUserId }; // Return customUserId if it exists
        }
    
        // If no customUserId is found, prompt the user to log in
        return null;
      }
    
      function showUserModal() {
        const userName = prompt("Please enter your name:");
        if (userName) {
          console.log("User name provided:", userName);
          createUser(userName);
        } else {
          console.log("No user name provided.");
        }
      }
    
      async function createUser(userName) {
        // Check if the user already exists in Firebase
        console.log("Searching for user in Firebase...");
        const existingUser = await findUserByName(userName);
        if (existingUser) {
          console.log("User already exists in Firebase:", existingUser);
          const customUserId = existingUser.customUserId;
          localStorage.setItem("customUserId", customUserId); // Save to localStorage
          console.log("User logged in successfully!");
          if (navigator.onLine) {
            syncDataWithFirebase(customUserId); // Sync data if online
          }
        } else {
          console.log("User does not exist. Creating new user...");
          const customUserId = generateCustomUserId(userName);
          localStorage.setItem("customUserId", customUserId); // Save to localStorage
    
          // Save the username and customUserId in Firebase
          await set(ref(db, `Users/${customUserId}/name`), userName);
          console.log("User created successfully in Firebase!");
          if (navigator.onLine) {
            syncDataWithFirebase(customUserId); // Sync data if online
          }
        }
      }
    
      async function findUserByName(userName) {
        // Query Firebase to find a user by name
        const usersRef = ref(db, "Users");
        const userQuery = query(usersRef, orderByChild("name"), equalTo(userName));
        const snapshot = await get(userQuery);
    
        if (snapshot.exists()) {
          // Return the first matching user's customUserId
          const userData = snapshot.val();
          const customUserId = Object.keys(userData)[0];
          console.log("User found in Firebase with customUserId:", customUserId);
          return { customUserId };
        } else {
          console.log("No user found in Firebase.");
          return null; // No user found
        }
      }
    
      function generateCustomUserId(userName) {
        // Generate a unique ID based on the username and a random string
        const randomString = Math.random().toString(36).substring(2, 10);
        return `${userName}-${randomString}`;
      }
    
      async function syncDataWithFirebase(customUserId) {
        disableUserInteraction(); // Disable user interaction while syncing
        showLoadingSpinner(true); // Show the loading spinner
        console.log("Syncing data with Firebase for user:", customUserId);
        const indexedDBData = await getIndexedDBData();
        await loadDataFromFirebase(customUserId);
    
        if (indexedDBData.length === 0) {
          console.log("IndexedDB is empty. Loading data from Firebase...");
          await loadDataFromFirebase(customUserId);
        } else {
          console.log("IndexedDB contains data. Uploading to Firebase...");
          await uploadDataToFirebase(customUserId, indexedDBData);
    
          console.log("Syncing IndexedDB with Firebase...");
          await syncIndexedDBWithFirebase(customUserId);
        }
        hideLoadingSpinner(); // Hide the loading spinner
        enableUserInteraction(); // Re-enable user interaction after syncing
      }
    
      async function getIndexedDBData() {
        const db = await initializeIndexedDB();
        return new Promise((resolve, reject) => {
          const modelNames = [
            "Worker", "Farmer", "DriedA", "DriedB", "FloatA", "FloatB", "Quaility", "visit",
            "In-House-Drying", "Dispatch-Of-Dried-Nutmeg", "Dispatch-Of-Green", "Cracking-Summary",
            "Floation-Summary", "Package-Ciontrol", "Editors", "Labour-support", "Training-support",
            "land-info", "Land-Tenur", "Nutmeg-Trees", "Nutmeg-Variety", "Other-Crops", "Coconut-Trees",
            "Citrus-Mango-Trees", "Other-Spices-Trees", "Other-Seasoning-Trees", "Other-Crops-Cultivated",
            "Condition", "Nutmeg-Land", "Nutmeg-Frequency", "Potential-Risks", "Road-Access",
            "Food-Safety-and-Quality", "Farm-Water-Source", "Farm-House", "inspector-symmary", "Policy",
            "Sanitation-A", "Sanitation-B", "Sanitation-C", "Cracking_Schedule", "Assorting_Log",
            "Extractor_Log", "Fumigation_Log", "Shelves", "W_Shelves", "M_Shelves", "W_Shelves_Dried",
            "M_Shelves_Dried", "Vehicle_Inspection", "Final_Weight_Inspection", "Final_Weight_Inspection_fields",
            "Dispatch_Of_Dried_Nutmeg_Rec", "Dispatch_Of_Green_Nutmeg_Rec", "Mace_Dispatched", "Mace_Purchase",
            "Mace_Dispatched_Rec", "Cracking_Extraction_Summary", "Day_Of_Loading", "TruckEntry",
            "Container_Inspection_Log"
          ];
    
          const allData = [];
    
          modelNames.forEach((modelName) => {
            const transaction = db.transaction(modelName, "readonly");
            const store = transaction.objectStore(modelName);
            const request = store.getAll();
    
            request.onsuccess = function () {
              allData.push({ modelName, data: request.result });
              if (allData.length === modelNames.length) {
                resolve(allData);
              }
            };
    
            request.onerror = function () {
              reject("Error reading data from IndexedDB");
            };
          });
        });
      }
    
      async function uploadDataToFirebase(customUserId, data) {
        try {
          console.log("Uploading data to Firebase...");
          const userRef = ref(db, `Users/${customUserId}/models`);
    
          for (const model of data) {
            const modelName = model.modelName;
            const modelData = model.data;
    
            const modelRef = ref(db, `Users/${customUserId}/models/${modelName}`);
            const newModelRef = push(modelRef); // Push creates a unique key for each new entry
    
            // Add data under the new unique key
            await set(newModelRef, modelData);
            console.log(`Uploaded ${modelData.length} items to Firebase for model ${modelName}`);
          }
    
          console.log("Data uploaded successfully to Firebase.");
        } catch (error) {
          console.error("Error uploading data to Firebase:", error);
        }
      }
    
      async function loadDataFromFirebase(customUserId) {
        console.log("Loading data from Firebase...");
        const userRef = ref(db, `Users/${customUserId}/models`);
        const snapshot = await get(userRef);
    
        if (snapshot.exists()) {
          const data = snapshot.val();
          for (const modelName in data) {
            const modelData = data[modelName];
            console.log(`Loading ${modelName} from Firebase`);
            await loadModelToIndexedDB(modelName, modelData);
          }
          console.log("Data successfully loaded from Firebase.");
        } else {
          console.log("No data found in Firebase.");
        }
      }
    
      async function loadModelToIndexedDB(modelName, modelData) {
        const db = await initializeIndexedDB();
        const transaction = db.transaction(modelName, "readwrite");
        const store = transaction.objectStore(modelName);
        modelData.forEach(item => {
          store.put(item); // Add or update the record in IndexedDB
        });
      }
    
      async function syncIndexedDBWithFirebase(customUserId) {
        console.log("Syncing IndexedDB with Firebase...");
    
        // First, get all the data from IndexedDB
        const indexedDBData = await getIndexedDBData();
        for (const model of indexedDBData) {
          const modelName = model.modelName;
          const modelData = model.data;
    
          // Upload the model data to Firebase
          await uploadDataToFirebase(customUserId, [{ modelName, data: modelData }]);
        }
        console.log("IndexedDB synced with Firebase.");
      }
    
      function disableUserInteraction() {
        // Disable interaction while syncing
        document.body.style.pointerEvents = "none";
        console.log("User interaction disabled.");
      }
    
      function enableUserInteraction() {
        // Enable interaction after syncing
        document.body.style.pointerEvents = "auto";
        console.log("User interaction enabled.");
      }
    
      function showLoadingSpinner(show) {
        const spinner = document.getElementById("loadingSpinner");
        if (show) {
          spinner.style.display = "block";
        } else {
          spinner.style.display = "none";
        }
      }
    
      function hideLoadingSpinner() {
        showLoadingSpinner(false);
      }
    
    </script>
     -->




    
    <!-- <script type="module">
      // Import Firebase modules
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-app.js";
      import { getDatabase, ref, set, get, push, query, orderByChild, equalTo } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-database.js";
      import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-auth.js";
    
      // Firebase configuration
      const firebaseConfig = {
        apiKey: "AIzaSyBZTB_mN_gIb6mqeM8nid4x83oKRehmFKo",
        authDomain: "farmer-project-sync.firebaseapp.com",
        databaseURL: "https://farmer-project-sync-default-rtdb.firebaseio.com",
        projectId: "farmer-project-sync",
        storageBucket: "farmer-project-sync.firebasestorage.app",
        messagingSenderId: "1366353203",
        appId: "1:1366353203:web:fa29fd29cc326a0d63ca46"
      };
    
      // Initialize Firebase
      const app = initializeApp(firebaseConfig);
      const db = getDatabase(app);
      const auth = getAuth(app);
    
      document.addEventListener("DOMContentLoaded", async function () {
        await initializeIndexedDB(); // Initialize IndexedDB first
        checkUserAndSyncData();
      });
    
      // Initialize IndexedDB and create object stores if they don't exist
      function initializeIndexedDB() {
        return new Promise((resolve, reject) => {
          const dbVersion = 2; // Increment this number if you change the schema
          var request = indexedDB.open("GCNA", dbVersion);
    
          request.onupgradeneeded = function (event) {
            var db = event.target.result;
            console.log("Database upgrade needed. Creating object stores...");
    
            const modelNames = [
          "Worker",
          "Farmer",
          "DriedA",
          "DriedB",
          "FloatA",
          "FloatB",
          "Quaility",
          "visit",
          "In-House-Drying",
          "Dispatch-Of-Dried-Nutmeg",
          "Dispatch-Of-Green",
          "Cracking-Summary",
          "Floation-Summary",
          "Package-Ciontrol",
          "Editors",
          "Labour-support",
          "Training-support",
          "land-info",
          "Land-Tenur",
          "Nutmeg-Trees",
          "Nutmeg-Variety",
          "Other-Crops",
          "Coconut-Trees",
          "Citrus-Mango-Trees",
          "Other-Spices-Trees",
          "Other-Seasoning-Trees",
          "Other-Crops-Cultivated",
          "Condition",
          "Nutmeg-Land",
          "Nutmeg-Frequency",
          "Potential-Risks",
          "Road-Access",
          "Food-Safety-and-Quality",
          "Farm-Water-Source",
          "Farm-House",
          "inspector-symmary",
          "Policy",
          "Sanitation-A",
          "Sanitation-B",
          "Sanitation-C",
          "Cracking_Schedule",
          "Assorting_Log",
          "Extractor_Log",
          "Fumigation_Log",
          "Shelves",
          "W_Shelves",
          "M_Shelves",
          "W_Shelves_Dried",
          "M_Shelves_Dried",
          "Vehicle_Inspection",
          "Final_Weight_Inspection",
          "Final_Weight_Inspection_fields",
          "Dispatch_Of_Dried_Nutmeg_Rec",
          "Dispatch_Of_Green_Nutmeg_Rec",
          "Mace_Dispatched",
          "Mace_Purchase",
          "Mace_Dispatched_Rec",
          "Cracking_Extraction_Summary",
          "Day_Of_Loading",
          "TruckEntry",
          "Container_Inspection_Log"
        ];
    
            modelNames.forEach((modelName) => {
              if (!db.objectStoreNames.contains(modelName)) {
                console.log(`Creating object store: ${modelName}`);
                db.createObjectStore(modelName, { keyPath: "id", autoIncrement: true });
              } else {
                console.log(`Object store already exists: ${modelName}`);
              }
            });
          };
    
          request.onsuccess = function (event) {
            resolve(event.target.result);
          };
    
          request.onerror = function (event) {
            reject("Error opening IndexedDB:", event);
          };
        });
      }
    
      async function checkUserAndSyncData() {
        const user = await getCurrentUser();
        if (!user) {
          showUserModal();
        } else {
          syncDataWithFirebase(user.customUserId); // Use customUserId for syncing
        }
      }
    
      async function getCurrentUser() {
        // Check if customUserId is already stored in localStorage
        const customUserId = localStorage.getItem("customUserId");
        if (customUserId) {
          return { customUserId }; // Return customUserId if it exists
        }
    
        // If no customUserId is found, prompt the user to log in
        return null;
      }
    
      function showUserModal() {
        const userName = prompt("Please enter your name:");
        if (userName) {
          createUser(userName);
        }
      }
    
      async function createUser(userName) {
        // Check if the user already exists in Firebase
        const existingUser = await findUserByName(userName);
        if (existingUser) {
          // User already exists, use their customUserId
          const customUserId = existingUser.customUserId;
          localStorage.setItem("customUserId", customUserId); // Save to localStorage
          console.log("User logged in successfully!");
          syncDataWithFirebase(customUserId);
        } else {
          // User does not exist, create a new user
          const customUserId = generateCustomUserId(userName);
          localStorage.setItem("customUserId", customUserId); // Save to localStorage
    
          // Save the username and customUserId in Firebase
          await set(ref(db, `Users/${customUserId}/name`), userName);
          console.log("User created successfully!");
          syncDataWithFirebase(customUserId);
        }
      }
    
      async function findUserByName(userName) {
        // Query Firebase to find a user by name
        const usersRef = ref(db, "Users");
        const userQuery = query(usersRef, orderByChild("name"), equalTo(userName));
        const snapshot = await get(userQuery);
    
        if (snapshot.exists()) {
          // Return the first matching user's customUserId
          const userData = snapshot.val();
          const customUserId = Object.keys(userData)[0];
          return { customUserId };
        } else {
          return null; // No user found
        }
      }
    
      function generateCustomUserId(userName) {
        // Generate a unique ID based on the username and a random string
        const randomString = Math.random().toString(36).substring(2, 10);
        return `${userName}-${randomString}`;
      }
    
      async function syncDataWithFirebase(customUserId) {
        const indexedDBData = await getIndexedDBData();
        if (indexedDBData.length === 0) {
          await loadDataFromFirebase(customUserId);
        } else {
          await uploadDataToFirebase(customUserId, indexedDBData);
        }
      }
    
      async function getIndexedDBData() {
        const db = await initializeIndexedDB();
        return new Promise((resolve) => {
          const modelNames = [
          "Worker",
          "Farmer",
          "DriedA",
          "DriedB",
          "FloatA",
          "FloatB",
          "Quaility",
          "visit",
          "In-House-Drying",
          "Dispatch-Of-Dried-Nutmeg",
          "Dispatch-Of-Green",
          "Cracking-Summary",
          "Floation-Summary",
          "Package-Ciontrol",
          "Editors",
          "Labour-support",
          "Training-support",
          "land-info",
          "Land-Tenur",
          "Nutmeg-Trees",
          "Nutmeg-Variety",
          "Other-Crops",
          "Coconut-Trees",
          "Citrus-Mango-Trees",
          "Other-Spices-Trees",
          "Other-Seasoning-Trees",
          "Other-Crops-Cultivated",
          "Condition",
          "Nutmeg-Land",
          "Nutmeg-Frequency",
          "Potential-Risks",
          "Road-Access",
          "Food-Safety-and-Quality",
          "Farm-Water-Source",
          "Farm-House",
          "inspector-symmary",
          "Policy",
          "Sanitation-A",
          "Sanitation-B",
          "Sanitation-C",
          "Cracking_Schedule",
          "Assorting_Log",
          "Extractor_Log",
          "Fumigation_Log",
          "Shelves",
          "W_Shelves",
          "M_Shelves",
          "W_Shelves_Dried",
          "M_Shelves_Dried",
          "Vehicle_Inspection",
          "Final_Weight_Inspection",
          "Final_Weight_Inspection_fields",
          "Dispatch_Of_Dried_Nutmeg_Rec",
          "Dispatch_Of_Green_Nutmeg_Rec",
          "Mace_Dispatched",
          "Mace_Purchase",
          "Mace_Dispatched_Rec",
          "Cracking_Extraction_Summary",
          "Day_Of_Loading",
          "TruckEntry",
          "Container_Inspection_Log"
        ];
    
          const allData = [];
          modelNames.forEach((modelName) => {
            if (!db.objectStoreNames.contains(modelName)) {
              console.warn(`Object store not found: ${modelName}`);
              return; // Skip this object store
            }
    
            const transaction = db.transaction(modelName, "readonly");
            const objectStore = transaction.objectStore(modelName);
            const getRequest = objectStore.getAll();
    
            getRequest.onsuccess = function (event) {
              const data = event.target.result;
              allData.push({ modelName, data });
              if (allData.length === modelNames.length) {
                resolve(allData);
              }
            };
    
            getRequest.onerror = function (event) {
              console.error(`Error fetching data from ${modelName}:`, event);
              resolve([]);
            };
          });
        });
      }
    
      async function loadDataFromFirebase(customUserId) {
        const snapshot = await get(ref(db, `Users/${customUserId}/models`));
        if (snapshot.exists()) {
          const data = snapshot.val();
          Object.keys(data).forEach((modelName) => {
            data[modelName].forEach((item) => {
              saveDataToIndexedDB(modelName, item);
            });
          });
        }
      }
    
      async function saveDataToIndexedDB(modelName, item) {
        const db = await initializeIndexedDB();
        const transaction = db.transaction(modelName, "readwrite");
        const objectStore = transaction.objectStore(modelName);
        objectStore.add(item);
      }
    
      async function uploadDataToFirebase(customUserId, data) {
        for (const { modelName, data: items } of data) {
          const modelRef = ref(db, `Users/${customUserId}/models/${modelName}`);
          for (const item of items) {
            const newEntryRef = push(modelRef);
            await set(newEntryRef, item);
          }
        }
      }
    </script> -->
    <!-- Required meta tags -->
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />

    <!-- Bootstrap CSS -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css"
      integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T"
      crossorigin="anonymous"
    />
    <link rel="stylesheet" href="style.css" />

    <title>GCNA</title>
  </head>
  <body style="background-color: rgba(4, 185, 94, 0.8)">
    {% include 'gcna/nav2.html' %}

    <br />
    <div class="container">{% block content%} {% endblock %}</div>

    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script
      src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
      integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/popper.js@1.14.7/dist/umd/popper.min.js"
      integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/js/bootstrap.min.js"
      integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
      crossorigin="anonymous"
    ></script>
  </body>
</html>
